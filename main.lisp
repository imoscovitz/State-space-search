;;;;
;;;; Ã¨lan Moscovitz
;;;; LISP implementation of three state space search techniques: uniform cost, greedy best first, and A*
;;;;

(defun insert-and-eliminate (child remaining added)
  (cond ((null remaining)
          (if (null added)
            (list child)))
        ((eq (second child) (second (car remaining)))
          (if (< (first child) (first (car remaining)))
            (if (null added)
                  (cons child (cdr remaining))
                  (cdr remaining))
            remaining))
        ((and (null added) (< (first child) (first (car remaining))))
            (cons child (insert-and-eliminate child remaining t)))
        (t (cons (car remaining) (insert-and-eliminate child (cdr remaining) added)))))

(defun ucs (problem)
  (do* ((explored nil (push state explored))
        (frontier (list (list 0 (get problem 'start-state) () 0)) frontier)
        (node (pop frontier) (pop frontier))
        (state (second node) (second node)))

        ((or (goal-test problem state) (null node))
          (if (goal-test problem state)
            (list (reverse (third node)) (fourth node))
            nil))

        (dolist (s (successors problem state))
          (unless (member (first s) explored)
            (let* ((child (make-child (cdr node) s)))
              (setf child (cons (third child) child))
              (setf frontier (insert-and-eliminate child frontier nil)))))))

(defun gbfs (problem)
  (do* ((explored nil (push state explored))
        (frontier (list (list (est-distance (get problem 'start-state) (get problem 'goal-state)) (list (get problem 'start-state) () 0))))
        (node (pop frontier) (pop frontier))
        (state (first (second node)) (first (second node))))

        ((or (goal-test problem state) (null node))
          (if (goal-test problem state)
            (list (reverse (second (second node))) (third (second node)))
            nil))

        (dolist (s (successors problem state))
          (unless (member (first s) explored)
            (let ((child (list (h s (get problem 'goal-state)) (make-child (second node) s))))
              (setf frontier (insert-and-eliminate child frontier nil)))))))

(defun a* (problem)
  (do* ((explored nil (push state explored))
        (frontier (list (list (est-distance (get problem 'start-state) (get problem 'goal-state)) (list (get problem 'start-state) () 0))))
        (node (pop frontier) (pop frontier))
        (state (first (second node)) (first (second node))))

        ((or (goal-test problem state) (null node))
          (if (goal-test problem state)
            (list (reverse (second (second node))) (third (second node)))
            nil))

        (dolist (s (successors problem state))
          (unless (member (first s) explored)
            (let ((child (list (f s (get problem 'goal-state)) (make-child (second node) s))))
              (setf frontier (insert-and-eliminate child frontier nil)))))))

(defun ucs-stats (problem)
  (let ((currentproblem nil)
        (problems '((Brest Marseille) (Montpellier	Calais) (Strasbourg	Bordeaux) (Paris Grenoble) (Grenoble	Paris)(Brest Grenoble)(Grenoble	Brest))))
    (dolist (c problems)
      (format t "~&~s ~s" (get currentproblem 'start-state) (get currentproblem 'goal-state))
      (setf (get currentproblem 'start-state) (first c))
      (setf (get currentproblem 'goal-state) (second c))
      (do* ((explored nil (push state explored))
            (frontier (list (list 0 (get currentproblem 'start-state) () 0)) frontier)
            (node (pop frontier) (pop frontier))
            (state (second node) (second node))
            (enteredCount 1 (1+ enteredCount))
            (exploredCount 0)
            (maintainedCount 0)
            (optimalCount 1))

            ((or (goal-test currentproblem state) (null node))
              (if (goal-test currentproblem state)
                (progn
                  (format t "~&~s" (list (list enteredCount exploredCount maintainedCount optimalCount)
                                       (list (reverse (third node)) (fourth node)))
                  (list (reverse (third node)) (fourth node)))))
                nil))

            (dolist (s (successors currentproblem state))
              (setf exploredCount (1+ exploredCount))
              (unless (member (first s) explored)
                (let* ((child (make-child (cdr node) s)))
                  (setf child (cons (third child) child))
                  (setf maintainedCount (- maintainedCount (length frontier)))
                  (setf frontier (insert-and-eliminate child frontier nil))
                  (setf maintainedCount (+ maintainedCount (length frontier))))))))))

(defun gbfs-stats (problem)
  (let ((currentproblem nil)
        (problems '((Brest Marseille) (Montpellier	Calais) (Strasbourg	Bordeaux) (Paris Grenoble) (Grenoble	Paris)(Brest Grenoble)(Grenoble	Brest))))
    (dolist (c problems)
      (format t "~&~s ~s" (get currentproblem 'start-state) (get currentproblem 'goal-state))
      (setf (get currentproblem 'start-state) (first c))
      (setf (get currentproblem 'goal-state) (second c))
      (do* ((explored nil (push state explored))
            (frontier (list (list (est-distance (get currentproblem 'start-state) (get currentproblem 'goal-state)) (list (get currentproblem 'start-state) () 0))))
            (node (pop frontier) (pop frontier))
            (state (first (second node)) (first (second node)))
            (enteredCount 1 (1+ enteredCount))
            (exploredCount 0)
            (maintainedCount 0)
            (optimalCount 0))

            ((or (goal-test currentproblem state) (null node))
              (if (goal-test currentproblem state)
                (progn
                  (if (eq (third (second node)) (second (ucs currentproblem)))
                    (setf optimalCount 1))
                  (format t "~&~s" (list (list enteredCount exploredCount maintainedCount optimalCount)
                                       (list (reverse (second (second node))) (third (second node)))))
                  (list (reverse (third node)) (fourth node))))
                nil))

            (dolist (s (successors currentproblem state))
              (setf exploredCount (1+ exploredCount))
              (unless (member (first s) explored)
                (let ((child (list (h s (get currentproblem 'goal-state)) (make-child (second node) s))))
                  (setf maintainedCount (- maintainedCount (length frontier)))
                  (setf frontier (insert-and-eliminate child frontier nil))
                  (setf maintainedCount (+ maintainedCount (length frontier))))))))))

(defun a*-stats (problem)
  (let ((currentproblem nil)
        (problems '((Brest Marseille) (Montpellier	Calais) (Strasbourg	Bordeaux) (Paris Grenoble) (Grenoble	Paris)(Brest Grenoble)(Grenoble	Brest))))
    (dolist (c problems)
      (format t "~&~s ~s" (get currentproblem 'start-state) (get currentproblem 'goal-state))
      (setf (get currentproblem 'start-state) (first c))
      (setf (get currentproblem 'goal-state) (second c))
      (do* ((explored nil (push state explored))
            (frontier (list (list (est-distance (get currentproblem 'start-state) (get currentproblem 'goal-state)) (list (get currentproblem 'start-state) () 0))))
            (node (pop frontier) (pop frontier))
            (state (first (second node)) (first (second node)))
            (enteredCount 1 (1+ enteredCount))
            (exploredCount 0)
            (maintainedCount 0)
            (optimalCount 0))

            ((or (goal-test currentproblem state) (null node))
              (if (goal-test currentproblem state)
                  (if (eq (third (second node)) (second (ucs currentproblem)))
                    (progn
                      (setf optimalCount 1))
                      (format t "~&~s" (list (list enteredCount exploredCount maintainedCount optimalCount)
                                          (list (reverse (second (second node))) (third (second node)))))
                                          (list (reverse (third node)) (fourth node))))
                (format t "~&~s" nil)))

            (dolist (s (successors currentproblem state))
              (setf exploredCount (1+ exploredCount))
              (unless (member (first s) explored)
                (let ((child (list (f s (get currentproblem 'goal-state)) (make-child (second node) s))))
                  (setf maintainedCount (- maintainedCount (length frontier)))
                  (setf frontier (insert-and-eliminate child frontier nil))
                  (setf maintainedCount (+ maintainedCount (length frontier))))))))))

(defun successors (problem state)
  (get state 'adj))

(defun make-child (node successor)
  (list
    (car successor)
    (cons (second successor) (second node))
    (+ (third successor) (third node))))

(defun goal-test (problem state)
  (equal (get problem 'goal-state) state))

(defun h (node goal)
  (est-distance (first node) goal))

(defun f (node goal)
  (+ (third node) (h node goal)))

(defun pc (degrees)
  (+ (first degrees) (/ (second degrees) 60.0) (/ (third degrees) 3600.0)))

(defun sqr (x)
  (* x x))

(defun est-distance (state1 state2)
  (let ((lat1 (pc (get state1 'latitude)))
        (lat2 (pc (get state2 'latitude)))
        (long1 (pc (get state1 'longitude)))
        (long2 (pc (get state2 'longitude))))

        (* 80 (sqrt (+ (sqr (- lat2 lat1)) (sqr (- long2 long1)))))))
